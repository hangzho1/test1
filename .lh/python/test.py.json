{
    "sourceFile": "python/test.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1663737218460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1663737232952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -734,9 +734,9 @@\n \r\n \r\n \r\n \r\n-from date\r\n+from datetime i\r\n \r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1663737234523,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -734,9 +734,9 @@\n \r\n \r\n \r\n \r\n-from datetime\r\n+from datetime import\r\n \r\n \r\n \r\n \r\n"
                }
            ],
            "date": 1663737218460,
            "name": "Commit-0",
            "content": "# num = list(map(int,input().split(r\",\")))\r\n# num = [-1, 0, 1, 2, -1, -4]\r\n# nums = sorted(num)\r\n# result = []\r\n# for a in range(len(nums)-2):\r\n#     for b in range( a+1,len(nums)-1):\r\n#         temp = nums[b+1:]\r\n#         if -a-b in temp:\r\n#             print(nums.index(-a-b))\r\n#         result.append([nums[a],nums[b],-a-b])\r\n# print(result)\r\n\r\n# nums = list(map(int,input().split()))\r\n# def max_sum(nums):\r\n#     dp = [None]*len(nums)\r\n#     res,dp[0] = nums[0],nums[0]\r\n#     a,b = 0,0\r\n#     hashmap = {}\r\n#     for i in range(1,len(nums)):\r\n#         if dp[i-1]+ nums[i] >= nums[i]:\r\n#             dp[i] = dp[i-1] +nums[i]\r\n#             b = i\r\n#             hashmap[dp[i]] = nums[a:b+1]\r\n#         else:\r\n#             a = b =i\r\n#             hashmap[dp[i]] = nums[a:b+1]\r\n#             dp[i] = nums[i]\r\n#         res = max(res,dp[i])\r\n#     return res,hashmap[res]\r\n# max_sum(nums)\r\n\r\n# 1143\r\n# text1 = str(input())\r\n# text2 = str(input())\r\n# text1 = \"abcba\"\r\n# text2 = \"abcbcba\"\r\n# def zvih(text1,text2):\r\n#     m,n = len(text1),len(text2)\r\n#     ## 这里定义的有问题，https://blog.csdn.net/yp736628082/article/details/87932962\r\n#     ## 因为列表可以存放不同类型的数据，所以列表可以读取一行，但是不能读取一列\r\n#     dp = [[0]*(n+1)]*(m+1)\r\n#     for i in range(m):\r\n#         for j in range(n):\r\n#             if text1[i] ==text2[j]:\r\n#                 dp[i+1][j+1] = dp[i][j] + 1\r\n#             else:\r\n#                 dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j])\r\n#     return dp[-1][-1]\r\n# zvih(text1,text2)\r\n\r\n\r\n# nums = [1,2,3]\r\n# nums = list(map(int,input().split()))\r\n# def permute(nums):\r\n#     def dfs(nums, size, depth, path, used, res):\r\n#         if depth == size:\r\n#             res.append(path[:])\r\n#             return\r\n\r\n#         for i in range(size):\r\n#             if not used[i]:\r\n#                 used[i] = True\r\n#                 path.append(nums[i])\r\n\r\n#                 dfs(nums, size, depth + 1, path, used, res)\r\n\r\n#                 used[i] = False\r\n#                 path.pop()\r\n\r\n#     size = len(nums)\r\n#     if len(nums) == 0:\r\n#         return []\r\n\r\n#     used = [False for _ in range(size)]\r\n#     res = []\r\n#     dfs(nums, size, 0, [], used, res)\r\n#     print(res)\r\n#     return res\r\n\r\n# permute(nums)\r\n\r\n\r\n# nums = list(map(int,input().split()))\r\n# nums = [1 ,3 ,5  ,6  ,7 ,9 ,10]\r\n# # target = int(input())\r\n# def two_search(nums,low,high,target):\r\n#     if low > high:return -1\r\n#     mid = low + (high - low)//2\r\n#     if nums[mid] == target:\r\n#         # print(mid)\r\n#         return mid\r\n#     elif nums[mid] > target:\r\n#         return two_search(nums,low,mid-1,target)\r\n#     else:\r\n#         return two_search(nums,mid+1,high,target)\r\n# two_search(nums,0,len(nums)-1,5)\r\n\r\n##正儿八经的快速排序\r\n# nums = list(map(int,input().split()))\r\n# nums = [3 ,2 ,9 ,-1 ,18]\r\n# def kkpd(nums,low,high):\r\n#     ### 本质上还是一个递归问题，所以必须要有终止条件\r\n    \r\n#     if low >= high:\r\n#         return nums\r\n#     ##这里不能这么写，因为是递归的过程，一直会变化，所以不能赋值稳定的值\r\n# #     i,j = 0,len(nums)-1\r\n#     i,j = low,high\r\n#     ### 基准参考线，随便取\r\n#     base = nums[i]\r\n#     while i < j:\r\n#         ###以做为基准哨兵必须也从j开始，比如2 3 1 0 2 5 3，第一次遍历之后应该为 1 0 2 3 2 5 3\r\n#         ### 而如果从i开始的话就会成为 3 0 1 2 2 5 3（因为不能保证i,j 相遇的值一定比基准值小）\r\n#         while i<j and nums[j] >base:\r\n#             j-=1\r\n#         while i<j and nums [i] < base:\r\n#             i+=1\r\n\r\n#         nums[i],nums[j] = nums[j],nums[i]\r\n#     nums[low],nums[i] = nums[i],nums[low]\r\n    \r\n#     ### 下面两个递归的左右边界参数怎么是个问题\r\n#     kkpd(nums,low,i-1)\r\n#     kkpd(nums,i+1,high)\r\n#     return nums\r\n# kkpd(nums,0,len(nums)-1)\r\n\r\n\r\n\r\n#\r\n# nums = [1,2,4,4,4,5,6,7,7,8]\r\n\r\n# if len(nums) <=1:print(len(nums))\r\n# for i in range(1,len(nums)):\r\n#     if nums[i] == nums[i-1]:\r\n#         nums[i] = nums[i] +1 \r\n# print(len(set(nums)))\r\n\r\n## 808 分汤\r\n# N = 101\r\n\r\n# def soupServings(N):\r\n#     Q, R = divmod(N, 25)\r\n#     N = Q + (R > 0)\r\n#     if N >= 500: return 1\r\n\r\n#     memo = {}\r\n#     def dp(x, y):\r\n#         if (x, y) not in memo:\r\n#             if x <= 0 or y <= 0:\r\n#                 ans = 0.5 if x<=0 and y<=0 else 1.0 if x<=0 else 0.0\r\n#             else:\r\n#                 ans = 0.25 * (dp(x-4,y)+dp(x-3,y-1)+dp(x-2,y-2)+dp(x-1,y-3))\r\n#             memo[x, y] = ans\r\n#         return memo[x, y]\r\n#     print(dp(N,N))\r\n#     return dp(N, N)\r\n# soupServings(N)\r\n\r\n\r\n# n =int(input())\r\n# nums = list(map(int,input().split()))\r\n# import bisect\r\n# n = 5\r\n# l = [1,2,8,6,4]\r\n# dp=[1]*n\r\n# valueList=[l[0]]\r\n# Max=1\r\n# for i in range(1,n):\r\n#     if l[i]>valueList[-1]:\r\n#         Max+=1\r\n#         dp[i]=Max\r\n#         valueList.append(l[i])\r\n#     else:\r\n#         index=bisect.bisect(valueList, l[i])\r\n#         dp[i]=index+1\r\n#         valueList[index]=l[i]\r\n# Max=max(dp)\r\n# res=[]\r\n# index=n-1-l[::-1].index(valueList[-1])\r\n# for i in range(index,-1,-1):\r\n#     if len(res)==0 or (l[i]<res[-1] and Max==dp[i]):\r\n#         res.append(l[i])\r\n#         Max-=1\r\n# print(' '.join(map(str,res[::-1])))\r\n\r\n# n = 7\r\n# nums = [2,1,3,4,3,1,4]\r\n# if n <=1:print(n)\r\n# temp = [nums[0]]\r\n# for i in range(1,len(nums)):\r\n#     if nums[i] + temp[-1]==10:\r\n\r\n#         del temp[-1]\r\n#     else:\r\n#         temp.append(nums[i])\r\n# print(len(temp))\r\n# a = \"1345\"\r\n\r\n# print(list(map(int,list(a))))\r\n\r\n\r\n# nums = list(map(int,input().split()))\r\n# target = int(input())\r\n'''\r\n二分查找\r\nnums  = [-3,-1,0.1,3,13]\r\ntarget = 0.1\r\n\r\n# def binarySearch(nums,target):\r\nleft,right = 0,len(nums)-1\r\nwhile left <= right:\r\n    mid = left + (right - left)//2\r\n    if nums[mid] == target:\r\n        print(mid)\r\n        break\r\n\r\n    elif nums[mid] > target:\r\n        right -=1\r\n    elif nums[mid] < target:\r\n        left +=1\r\nprint(-1)\r\n    # return -1\r\n# binarySearch(nums,target)\r\n'''\r\n\r\n\r\n# x,y  = list(map(int,input().split()))\r\n# x,y =2,6\r\n# def lcm(x,y):\r\n#     greater = max(x,y)\r\n#     while 1:\r\n#         if greater %x ==0 and greater %y ==0:\r\n# #             lcm = greater\r\n#             break\r\n#         greater +=1\r\n#     print(greater)\r\n#     return \"gg\"\r\n# lcm(x,y)\r\n# print(lcm(x,y))\r\n# print(5)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n'''\r\nclass ListNode:\r\n    def __init__(self,x):\r\n        self.val = x\r\n        self.next = None\r\nnums,pos = list(input().split(\",\"))\r\nhead = list(map(int,nums.split()))\r\nroot = ListNode(head[0])\r\nnodes = {head[0]:root}\r\nfor i in range(1,len(head)):\r\n    nodes[head[i]] = ListNode(head[i])\r\n#     print(type(ListNode(head[i])))\r\n    nodes[head[i-1]].next = nodes[head[i]]\r\nnodes[head[len(head)-1]].next = ListNode(list(nodes)[int(pos)])\r\nprint(type(list(nodes)[int(pos)]))\r\n\r\ndef hasCycle(head):\r\n    if not head or not head.next:\r\n        print(False)\r\n        return \r\n    slow,fast = head,head.next\r\n    while slow != fast:\r\n        if not fast or not fast.next:\r\n            print(False)\r\n            return\r\n        slow = slow.next\r\n        fast =fast.next.next\r\n    print(True)\r\nif int(pos)==-1:\r\n    print(False)\r\nhasCycle(root)\r\n'''\r\n\r\n# n,m=map(int,input().split())\r\n# # l=list(range(1,n+1))\r\n# res=0\r\n# for i in range(1,n+1):\r\n#     res=(res+m)%i\r\n# print(res+1)\r\n\r\n\r\n'''\r\nimport bisect\r\n# import bisect\r\nA = [2,1,4,3,1,5,6]\r\nn = 7\r\nif n <=1:print(n)\r\ndp  = [1]*n \r\nvalues = [A[0]]\r\nfor i in range(1,n):\r\n    if A[i] > values[-1]:\r\n        dp[i] = max(dp) +1 \r\n        values.append(A[i])\r\n    else:\r\n        index = bisect.bisect(values,A[i])\r\n        dp[i] = index +1\r\n        values[index] = A[i]\r\nprint(max(dp))\r\n'''\r\n\r\n##1190\r\n# str1 = input()\r\n# stack = []\r\n# word= \"\"\r\n# for c in str1:\r\n#     if c == \"(\":\r\n#         stack.append(word)\r\n#         word = \"\"\r\n#     elif c == \")\":\r\n#         word = stack.pop(-1) +word[::-1]\r\n#     else:\r\n#         word += c\r\n# print(word)\r\n\r\n\r\n\r\n\r\n\r\n\r\n# ### 快速排序\r\n# nums = list(map(int,input().split()))\r\n# def quickSort(nums,low,high):\r\n#     if low >= high:\r\n#         # print(nums)\r\n#         return\r\n#     ##设置哨兵\r\n#     i,j = low,high\r\n#     ##nums[low]和nums[i]都一样\r\n#     target = nums[low]\r\n#     while i < j:\r\n#         while i < j and nums[j] > target:\r\n#             j-=1\r\n#         while i< j and nums[i] <= target:\r\n#             i+=1\r\n#         nums[i],nums[j] = nums[j],nums[i]\r\n#     nums[low],nums[i] = nums[i],nums[low]\r\n#     quickSort(nums,low,i-1)\r\n#     quickSort(nums,i+1,high)\r\n#     print(nums)\r\n#     return nums\r\n# quickSort(nums,0,len(nums)-1)\r\n\r\n\r\n# 把ab编程bba\r\n\r\n# str1 = input()\r\n# def number(str1):\r\n#     res = 0\r\n#     for i in range(len(str1)-1):\r\n#         if \"ab\" not in str1:\r\n#             return res\r\n#         else:\r\n#             if str1[i:i+2] ==\"ab\":\r\n#                 str1 = str1[:i] + \"bba\" + str1[i+2:]\r\n#                 res += 1\r\n#                 res %=1000000007\r\n#     return res\r\n# out = number(str1)               \r\n# print(out)\r\n\r\n## 2\r\n# def is_ab(s):\r\n#     i= res = 0\r\n#     for i in range(len(s)-1):\r\n#         if s[i:i+2] == \"ab\":\r\n#             res += 1\r\n#             res %= 1000000007\r\n#     return res\r\n# s = input()\r\n# num = is_ab(s)\r\n# while is_ab(s) != 0:\r\n#     s = s.replace(\"ab\",\"bba\")\r\n#     num = num + is_ab(s)\r\n# print(num)\r\n        \r\n# strs = input().split(\",\")\r\n# def comonLength(strs):\r\n#     res = \"\"\r\n#     for i in zip(*strs):\r\n#         if len(set(i)) == 1:\r\n#             res += i[0]\r\n#         else:\r\n#             break\r\n# #     print(res)\r\n#     return res\r\n# print(comonLength(strs))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# nums = list(map(int,input().split()))\r\n\r\n# print(sum(nums),type(nums[1]))\r\n# a = 6\r\n# b=4\r\n# print(max(a,b))\r\n# a = [1,3,5]\r\n# b = []\r\n# print(b.append(sum(a)))\r\n\r\n\r\n\r\n# n = int(input())\r\n# nums = list(map(int,input().split()))\r\n# n = 10\r\n# nums =[1,2,3,4,5,6,7,8,9,10]\r\n# res = [0]\r\n# def xibo(nums):\r\n#     temp = []\r\n#     for i in range(n):\r\n#         a = nums[i]*(-1)**i\r\n#         temp.append(a)\r\n#     temp =sum(temp)\r\n#     res.append(temp)\r\n# for i in range(n):\r\n#     for j in range(n):\r\n#         xibo(nums[j:j+i])\r\n# xibo(nums)\r\n# print(max(res))\r\n# a = []\r\n# print(len(a))\r\n# for i in range(len(a)):\r\n#     print(5)\r\n\r\n\r\n# a = 0\r\n# for i in range(0):\r\n#     for j in range(i):\r\n#         print(j)\r\n\r\n# a = [1,3,5]\r\n# b = []\r\n# b.append(sum(a))\r\n# print(b)\r\n\r\n# a = \"abc\"\r\n# b = \"abc\"\r\n# if a == b:\r\n#     print(5)\r\n\r\n\r\n\r\n# nums = list(map(int,input().split()))\r\n# def heapSort(nums):\r\n#     ##交换数组中的数字\r\n#     def swap(nums,a,b):\r\n#         nums[a],nums[b] = nums[b],nums[a]\r\n#         return\r\n#     ###堆化过程\r\n#     def heap(nums,k,i):\r\n#         while True:\r\n#             max_index = i\r\n#             if i*2 + 1 < k and nums[i*2+1] > nums[max_index]:\r\n#                 max_index = i*2 + 1\r\n#             elif i*2 + 2 < k and nums[i*2+2] > nums[max_index]:\r\n#                 max_index = i*2 + 2\r\n#             elif max_index == i:\r\n#                 break\r\n#             swap(nums,max_index,i)\r\n#             i = max_index\r\n#     ##建堆\r\n#     for i in range(len(nums)//2,-1,-1):\r\n#         heap(nums,len(nums),i)\r\n#     ##排序过程\r\n#     for i in range(len(nums)-1,0,-1):\r\n#         swap(nums,i,0)\r\n#         heap(nums,i,0)\r\n#     return nums\r\n# heapSort(nums)\r\n\r\n\r\n\r\n# n = int(input())\r\n# nums  = list(map(int,input().split()))\r\n# n = 7\r\n# temp = []\r\n# res = []\r\n# nums = [5,4,5,4,4,1,3]\r\n# for i in range(1,len(nums)):\r\n#     if nums[i] > nums[i-1]:\r\n#         temp.append(i-1)\r\n# print(temp)\r\n# for i in range(n):\r\n#     if i not in temp:\r\n#         res.append(nums[i])\r\n# print(*res)\r\n\r\n\r\n# n  = int(input())\r\n# hashmap = {}\r\n\r\n# def mapAddress(x):\r\n#     if x[0] == \"Add\":\r\n#         hashmap[x[1]] = [x[2],x[3]]\r\n#     elif x[0] == \"Change\":\r\n#         hashmap[x[1]] = [x[2],x[3]]\r\n#     elif x[0] == \"Delete\":\r\n#         del hashmap[x[1]]\r\n#     elif x[0] == \"Query\":\r\n#         if x[1] in hashmap:\r\n#             print(\"yes\")\r\n#             print(*hashmap[x[1]])\r\n#         else:\r\n#             print(\"no\")\r\n#     else:\r\n#         return\r\n# for i in range(n):\r\n#     x = input().split()\r\n#     mapAddress(x)\r\n\r\n\r\n\r\n# ma = []\r\n# x = list(map(int,input().split()))\r\n# n,m,k,x1,y1 = x[0],x[1],x[2],x[3],x[4]\r\n# for i in range(x[0]):\r\n#     ix =list(map(int,input().split()))\r\n#     ma.append(ix)\r\n# sm = []\r\n# xp,yp = x1 -1 ,y1-1\r\n\r\n# def dfs(x,y,k,su,ma):\r\n#     if x < 0 or x > n-1 or y < 0 or y > m-1 or ma[x][y] == -1 or k<0:\r\n#         return\r\n#     elif x == xp and y == yp and k>=0:\r\n#         su += ma[x][y]\r\n#         sm.append(su)\r\n#         return \r\n#     else:\r\n#         su +=ma[x][y]\r\n#         ma[x][y] = 0\r\n#         k-=1\r\n#         dfs(x+1,y,k,su,ma)\r\n#         dfs(x-1,y,k,su,ma)\r\n#         dfs(x,y+1,k,su,ma)\r\n#         dfs(x,y-1,k,su,ma)\r\n# dfs(xp+ 1,yp,k,0,ma) \r\n# dfs(xp- 1,yp,k,0,ma) \r\n# dfs(xp,yp+1,k,0,ma) \r\n# dfs(xp,yp-1,k,0,ma) \r\n# print(max(sm))\r\n\r\n\r\n\r\n# a= [5,4,5,4,4,1,3]\r\n# def comp(a):\r\n#     for i in range(len(a) -1 ):\r\n#         if a[i+1] > a[i]:\r\n#             del a[i]\r\n#             return comp(a)\r\n#     return a\r\n\r\n# print(comp(a))\r\n\r\n\r\n\r\n\r\n# m,n = map(int,input().split())\r\n# matrix = []\r\n# for _ in range(m):\r\n#     matrix.append(list(map(int,input().split()))\r\n\r\n# def matrixSet0(matrix):\r\n#     ##放置为0 的行数和列数\r\n#     set_i,set_j = set(),set()\r\n#     ##第一吃遍历找出哪些行和列为0\r\n#     for i in range(m):\r\n#         for j in range(n):\r\n#             if matrix[i][j]==0:\r\n#                 set_i.add(i)\r\n#                 set_j.add(j)\r\n#     ###第二次遍历 赋值改变\r\n#     for i in range(m):\r\n#         for j in  range(n):\r\n#             if i in set_i or j in set_j:\r\n#                 matrix[i][j] =0\r\n#     return matrix\r\n# matrixSet0(matrix)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# m,n = map(int,input().split())\r\n# coun = []\r\n# for i in range(m):\r\n#     coun.append(list(map(str,input())))\r\n\r\n# def dfs(coun,i,j,x):\r\n#     if i < 0 or i>=m or j < 0 or j >=n or coun[i][j] != x:\r\n#         return\r\n#     coun[i][j] = \"*\"\r\n#     dfs(coun,i+1,j,x)\r\n#     dfs(coun,i-1,j,x)\r\n#     dfs(coun,i,j+1,x)\r\n#     dfs(coun,i,j-1,x)\r\n# def num(coun):\r\n#     if not coun:\r\n#         return 0 \r\n#     res =0 \r\n#     for i in range(m):\r\n#         for j in range(n):\r\n#             if coun[i][j] != \"*\":\r\n#                 dfs(coun,i,j,coun[i][j])\r\n#                 res += 1\r\n#     return res\r\n# print(num(coun))\r\n\r\n# a = [1,2,3]\r\n\r\n# hashmap={}\r\n# a = hashmap.fromkeys(a,[])\r\n\r\n# print(hashmap,a)\r\n\r\n# a ={1: [], 2: [], 3: []}\r\n# print(len(a),a,hashmap)\r\n\r\n\r\n# a = \"k:1  |k1:2|k2:3|k3:4\"\r\n# a = a.replace(\" \",\"\")\r\n# print(a)\r\n\r\n# # # print(a)\r\n# # # hashmap = {}\r\n# # # for item in a.split(\"|\"):\r\n# # #     key,value = item.split(\":\")\r\n# # #     hashmap[key] = value\r\n# # # print(a,hashmap)\r\n# # d = {k:v for t in a.split(\"|\")for k,v in (t.split(\":\"),)}\r\n# # print(a,d)\r\n\r\n\r\n\r\n\r\n\r\n# from time import time, sleep\r\n# def run_time(func):\r\n#     def wrapper():\r\n#         start = time()\r\n#         func()\r\n#         end = time()\r\n#         cost_time = end - start\r\n#         print(\"func three run time {}\".format(cost_time))\r\n#     return wrapper\r\n\r\n# @run_time\r\n# def fun_one():\r\n#     sleep(1)\r\n    \r\n# @run_time\r\n# def fun_two():\r\n#     sleep(1)\r\n    \r\n# @run_time\r\n# def fun_three():\r\n#     sleep(1)\r\n    \r\n# fun_one()\r\n# fun_two()\r\n# fun_three()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
        }
    ]
}