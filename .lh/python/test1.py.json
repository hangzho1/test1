{
    "sourceFile": "python/test1.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1663750013304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1663750746248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -606,8 +606,8 @@\n b = a.split()\r\n print(b)\r\n print(b[-5])\r\n print(b[-1].strip(\"()\"))\r\n-print(100)\r\n+print(154)\r\n \r\n # c = \"(0.000)\"\r\n # print(c.strip(\"()\"))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1663750761977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -606,8 +606,8 @@\n b = a.split()\r\n print(b)\r\n print(b[-5])\r\n print(b[-1].strip(\"()\"))\r\n-print(154)\r\n+print(150)\r\n \r\n # c = \"(0.000)\"\r\n # print(c.strip(\"()\"))\n\\ No newline at end of file\n"
                }
            ],
            "date": 1663750013304,
            "name": "Commit-0",
            "content": "# nums =list(map(int,input().split()))\r\n# #nums = [3 ,2 ,9 ,-1 ,18]\r\n# def kkpd(nums,low,high):\r\n#     ### 本质上还是一个递归问题，所以必须要有终止条件\r\n    \r\n#     if low >= high:\r\n#         return nums\r\n#     ##这里不能这么写，因为是递归的过程，一直会变化，所以不能赋值稳定的值\r\n# #     i,j = 0,len(nums)-1\r\n#     i,j = low,high\r\n#     ### 基准参考线，随便取\r\n#     base = nums[i]\r\n#     while i < j:\r\n#         ###以做为基准哨兵必须也从j开始，比如2 3 1 0 2 5 3，第一次遍历之后应该为 1 0 2 3 2 5 3\r\n#         ### 而如果从i开始的话就会成为 3 0 1 2 2 5 3（因为不能保证i,j 相遇的值一定比基准值小）\r\n#         while i<j and nums[j] >base:\r\n#             j-=1\r\n#         while i<j and nums [i] <= base:\r\n#             i+=1\r\n\r\n#         nums[i],nums[j] = nums[j],nums[i]\r\n#     nums[low],nums[i] = nums[i],nums[low]\r\n    \r\n#     ### 下面两个递归的左右边界参数怎么是个问题\r\n#     kkpd(nums,low,i-1)\r\n#     kkpd(nums,i+1,high)\r\n#     return nums\r\n# kkpd(nums,0,len(nums)-1)\r\n\r\n\r\n\r\n# arr = input().split(\",\")\r\n# print(arr,type(arr))\r\n# hashmap = {}\r\n# for i in arr:\r\n#     hashmap[i] = hashmap.get(0,i) + 1\r\n# print(hashmap,len(hashmap))\r\n# print(list(hashmap),len(list(hashmap)))\r\n\r\n\r\n# s = 7\r\n# nums = [2,3,1,2,4,3]\r\n# def minSubArrayLen(s,nums):\r\n#     if sum(nums) < s:\r\n#         return 0\r\n#     minLen = len(nums)\r\n#     for i  in range(len(nums)):\r\n#         for j in range(i,i+minLen):\r\n#             if  sum(nums[i:j+1]) >= s:\r\n#                 minLen = j-i+1\r\n#     return minLen\r\n# minSubArrayLen(s,nums)\r\n\r\n\r\n# a = [1,2,4,2,4,5,6,5,7,8,9,0]\r\n# b = {}\r\n# b = b.fromkeys(a,1)\r\n# print(b)\r\n# print(list(b.keys()),b.values())\r\n\r\n\r\n\r\n# num = \"1000\"\r\n# def maxLexicographical( num ):\r\n#     nums = list(num)\r\n#     flag = False\r\n#     for i in range(len(nums)):\r\n#         if nums[i] == '0':\r\n#             nums[i] = '1'\r\n#             flag = True\r\n#             continue\r\n#         if flag and nums[i] == '1':\r\n#             break\r\n#     return \"\".join(nums)\r\n# print(maxLexicographical(num))\r\n\r\n\r\n# input1 = input()\r\n# m  = int(input1.split(\",\")[0])\r\n# k = int(input1.split(\",\")[1])\r\n# # print(m,k)\r\n# def jinzhi(n,k):\r\n#     b = []\r\n#     while True:\r\n#         s = n//k\r\n#         y = n%k\r\n#         b = b + [y]\r\n#         if s==0:\r\n#             return b\r\n#         n =s\r\n# res,start = 0,1\r\n# while res < m:\r\n\r\n#     b = jinzhi(start,k)\r\n#     for i in b:\r\n#         strb = str(i)\r\n#         for j in range(len(strb)):\r\n#             if strb[j] == \"1\":\r\n#                 res += 1\r\n#     start +=1\r\n# print(start-1)\r\n\r\n# n  = int(input())\r\n# preNums = list(map(int,input().split()))\r\n\r\n# nums = sorted(preNums)\r\n# left,right = len(nums),0\r\n# for i in range(len(nums)):\r\n#     if nums[i] != preNums[i]:\r\n#         left = min(left,i)\r\n#         right = i\r\n# if right ==0:\r\n#     print(0)\r\n# else:\r\n#     print((right - left+1)//2)\r\n\r\n\r\n\r\n# nums = list(map(int,input().split()))\r\n# print(nums)\r\n\r\n\r\n\r\n# n = int(input())\r\n# str1 = input()\r\n# def count(str1):\r\n#     if not str1:\r\n#         return 0\r\n#     if \"B\" not in str1 or \"R\" not in str1:\r\n#         return 1\r\n#     res = []\r\n#     for i in range(len(str1)-1):\r\n#         if str1[i+1] != str1[i] :\r\n#             if i != len(str1) -2:\r\n#                 res.append(str1[i])\r\n#             else:\r\n#                 res.extend([str1[i],str1[i+1]])\r\n        \r\n#         if str1[i+1] == str1[i] and i == len(str1)-2:\r\n#             res.append(str1[i])\r\n#     print(res)\r\n#     hashmap ={}\r\n#     for i in res:\r\n#         hashmap[i] = hashmap.get(i,0) + 1\r\n#     return min(1 + hashmap[\"B\"],1 + hashmap[\"R\"],hashmap[\"R\"] + hashmap[\"B\"])\r\n# print(count(str1))\r\n\r\n# heroes = [[60,35,20],[30,40,30],[40,50,40],[50,60,50],[55,45,60]]\r\n# # heroes = [[4,5,1,1],[6,4,2,2],[7,3,3,3]]\r\n# def count(heroes):\r\n#     res = 0\r\n#     m,n = len(heroes),len(heroes[0])\r\n#     for i in range(m-1):\r\n#         for j in range(i+1,m):\r\n#             if heroes[i][0] > heroes[j][0]:\r\n#                 res1 = 1\r\n#             else:\r\n#                 res1 = 0\r\n#             for x in range(n):\r\n#                 if heroes[i][x] > heroes[j][x]:\r\n#                     res2 = 1\r\n#                 else:\r\n#                     res2 = 0\r\n#                 if res1 != res2:\r\n#                     break\r\n#                 if x == n-1:\r\n#                     res += 1\r\n#     return res\r\n\r\n# print(count(heroes))\r\n\r\n\r\n\r\n\r\n# class TreeNode:\r\n#     def __init__(self,x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n# # def preOrder(root):\r\n# #     ans = []\r\n# #     if not root:\r\n# #         return ans\r\n# #     ans.append(root.val)\r\n# #     ans.extend(preOrder(root.left))\r\n# #     ans.extend(preOrder(root.right))\r\n# #     return ans\r\n\r\n\r\n# def preOrder(root):\r\n#     stack,ans = [root],[]\r\n#     while stack:\r\n#         i = stack.pop()\r\n#         if isinstance(i,TreeNode):\r\n#             stack.extend([i.right,i.left,i.val])\r\n#         if isinstance(i,int):\r\n#             ans.append(i)\r\n#     return ans\r\n\r\n\r\n\r\n# n,root = map(int,input().split())\r\n# node = {root:TreeNode(root)}\r\n# for _ in range(n):\r\n#     fa,lch,rch = map(int,input().split())\r\n#     if lch != 0:\r\n#         node[lch] = TreeNode(lch)\r\n#         node[fa].left = node[lch]\r\n#     if lch != 0:\r\n#         node[rch] = TreeNode(rch)\r\n#         node[fa].right = node[rch]\r\n\r\n# print(preOrder(node[root]))\r\n\r\n\r\n\r\n\r\n\r\n# a = [1,2,3,4,5]\r\n# b = a[1:3]\r\n# print(a,b)\r\n# b[1] = 100\r\n# print(a,b)\r\n\r\n\r\n# class TreeNode:\r\n#     def __init__(self,x,left = None,right = None):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n# def isValid(root):\r\n#     if not root:\r\n#         return True\r\n#     def dfs(left, right):\r\n#         if not(left or right):\r\n#             return True\r\n#         if not(left and right):\r\n#             return False\r\n#         if left.val != right.val:\r\n#             return False\r\n#         return dfs(left.left,right.right) and dfs(left.right,right.left)\r\n\r\n#     return dfs(root.left,root.right)\r\n\r\n# node = {1:TreeNode(1)}\r\n# for i in range(3):\r\n#     fa, lch, rch = map(int,input().split())\r\n#     if lch != 0:\r\n#         node[lch] = TreeNode(lch)\r\n#         node[fa].left = node[lch]\r\n#     if rch != 0:\r\n#         node[rch] = TreeNode(rch)\r\n#         node[fa].right = node[rch]\r\n# print(node)\r\n# print(isValid(node[1]))\r\n\r\n\r\n\r\n# s = \"abab\"\r\n\r\n# def number(str1):\r\n#     i = res = 0\r\n#     while \"ab\" in str1:\r\n#         if str1[i:i+2] ==\"ab\":\r\n#             str1 = str1[:i] + \"bba\" + str1[i+2:]\r\n#             res += 1\r\n#             res %=1000000007\r\n#             i -= 1\r\n#         else:\r\n#             i += 1\r\n#     return res\r\n# out = number(str1)               \r\n# print(out)\r\n# s = s.replace(\"ab\",\"bba\")\r\n# print(s)\r\n\r\n\r\n\r\n# def is_ab(s):\r\n#     i= res = 0\r\n#     for i in range(len(s)-1):\r\n#         if s[i:i+2] == \"ab\":\r\n#             res += 1\r\n#             res %= 1000000007\r\n#     return res\r\n# s = input()\r\n# num = is_ab(s)\r\n# while is_ab(s) != 0:\r\n#     s = s.replace(\"ab\",\"bba\")\r\n#     num = num + is_ab(s)\r\n# print(num)\r\n        \r\n\r\n\r\n# nums = [1,2,3,4,5,6]\r\n# i,j = 1,len(nums)-1\r\n\r\n# while i < j:\r\n#     nums.insert(i,nums.pop(j))\r\n#     print(nums)\r\n#     i+=2\r\n# print(nums)\r\n\r\n\r\n# print ([[x for x in range(1,100)] [i:i+3] for i in range(0,100,3)])\r\n# print ([[x for x in range(1,100)]])\r\n\r\n# path1 = [1,3,4]\r\n# a = 0\r\n# def b():\r\n#     # global a\r\n#     # a += 1\r\n#     # return path1\r\n#     c = a +1\r\n#     print(c)\r\n\r\n# print(a,b(),path1,a)\r\n# def main():\r\n#     f = open('致橡树.txt', 'r', encoding='utf-8')\r\n#     print(f.read())\r\n#     f.close()\r\n\r\n\r\n# if __name__ == '__main__':\r\n#     main()\r\n\r\n# def longestPalindrome(s):\r\n#     if len(s) <=1:\r\n#         return s \r\n        \r\n#     def centerSpread(s,left,right):\r\n#         while left >= 0 and right < len(s) and s[left] == s[right]:\r\n#             left -= 1\r\n#             right += 1\r\n#         return s[left+1:right]\r\n\r\n#     res = \"\"\r\n#     for i in range(len(s)):\r\n#         odd = centerSpread(s,i,i)\r\n#         even = centerSpread(s,i,i+1)\r\n#         res = max(odd,even,res,key = len)\r\n#     return res \r\n\r\n# print(longestPalindrome(\"babad\"))\r\n\r\n\r\n# nums = [1,2,3]\r\n\r\n# def permute(nums):\r\n#     res,path,n ,boolea = [],[],len(nums),[False]*3\r\n\r\n#     def dfs(path):\r\n#         if len(path) == n:\r\n#             return res.append(path[:])\r\n#         for i in range(n):\r\n#             if not boolea[i]:\r\n#                 boolea[i] = True\r\n#                 path.append(nums[i])\r\n#                 dfs(path)\r\n#                 path.pop()\r\n#                 boolea[i] = False\r\n#     dfs(path)\r\n#     return len(res),res\r\n\r\n# print(permute(nums))\r\n\r\n\r\n\r\n\r\n# nums = [1,2,3]\r\n# a = 100 \r\n# def permute(nums):\r\n\r\n#     res,path,n ,boolea = [],[],len(nums),[False]*3\r\n#     def dfs(path):\r\n\r\n#         if len(path) == n:\r\n#             return res.append(path)\r\n        \r\n\r\n#         for i in range(n):\r\n#             if not boolea[i]:\r\n#                 boolea[i] = True\r\n#                 # path.append(nums[i])\r\n#                 dfs(path + [nums[i]])\r\n#                 # path.pop()\r\n#                 boolea[i] = False\r\n#     dfs(path)\r\n#     return len(res),res,a,n\r\n\r\n\r\n# n = int(input())\r\n# str1 = input()\r\n# def count(str1):\r\n#     if not str1:\r\n#         return 0\r\n#     if \"B\" not in str1 or \"R\" not in str1:\r\n#         return 1\r\n#     res = []\r\n#     for i in range(len(str1)-1):\r\n#         if str1[i+1] != str1[i] :\r\n#             if i != len(str1) -2:\r\n#                 res.append(str1[i])\r\n#             else:\r\n#                 res.extend([str1[i],str1[i+1]])\r\n        \r\n#         if str1[i+1] == str1[i] and i == len(str1)-2:\r\n#             res.append(str1[i])\r\n\r\n#     hashmap ={}\r\n#     for i in res:\r\n#         hashmap[i] = hashmap.get(i,0) + 1\r\n#     print(hashmap)\r\n#     return min(1 + hashmap[\"B\"],1 + hashmap[\"R\"],hashmap[\"R\"] + hashmap[\"B\"])\r\n# print(count(str1))\r\n\r\n\r\n\r\n# matrix = [[1,2,3],[4,5,6],[7,8,9]]\r\n\r\n# def spiralOrder(matrix):\r\n#     res = []\r\n#     up,down,left,right = 0,len(matrix)-1,0,len(matrix[0])-1\r\n#     while  1:\r\n#         for i in range(left,right+1):\r\n#             res.append(matrix[up][i])\r\n#         up += 1\r\n#         if up > down:\r\n#             break\r\n#         for i in range(up,down+1):\r\n#             res.append(matrix[i][right])\r\n#         right -= 1\r\n#         if right < left:\r\n#             break\r\n#         for i in range(right,left-1,-1):\r\n#             res.append(matrix[down][i])\r\n#         down -= 1\r\n#         if up > down:\r\n#             break\r\n#         for i in range(down,up-1,-1):\r\n#             res.append(matrix[i][left])\r\n#         left += 1\r\n#         if left > right:\r\n#             break\r\n#     return res\r\n# print(spiralOrder(matrix))\r\n\r\n\r\n\r\n\r\n# nums = [-1,0,3,5,9,12]\r\n# target=9\r\n\r\n# ## 非递归\r\n# def binarySearch():\r\n#     left,right = 0,len(nums)-1\r\n#     while left <= right:\r\n#         mid = left + (right - left)//2\r\n#         if nums[mid] ==target:\r\n#             return  mid\r\n#         if nums[mid] > target:\r\n#             right = mid -1\r\n#         else:\r\n#             left = mid + 1\r\n#     return -1\r\n# print(binarySearch())\r\n\r\n\r\n# nums = [10,9,2,5,3,7,101,18]\r\n\r\n# def lengthOfLIS():\r\n#     if len(nums)<=1:\r\n#         return len(nums)\r\n#     res = [1]*len(nums)\r\n#     for i in range(1,len(nums)):\r\n#         for j in range(i):\r\n#             if nums[j] < nums[i]:\r\n#                 res[i] = max(res[i],res[j]+1)\r\n#     return max(res)\r\n\r\n# print(lengthOfLIS())\r\n\r\n\r\n# import os\r\n# save_path = \"G:/study/screencaptura/a/b\"\r\n# if not os.path.exists(save_path):\r\n#     os.mkdir(save_path)\r\n    \r\n\r\n# a = 100 \r\n# def abb():\r\n    \r\n#     # global a\r\n#     def acc():\r\n#         global a\r\n#         a = 111\r\n#     acc()\r\n\r\n\r\n\r\n\r\n\r\n\r\n# need=collections.defaultdict(int)\r\n# print(need)\r\n\r\n\r\n# a = [1,2,4,2,4,5,6,5,7,8,9,0]\r\n# b = {}\r\n# b = b.fromkeys(a,1)\r\n# print(b)\r\n# print(list(b.keys()),b.values())\r\n\r\n\r\n# t = \"abc\"\r\n# need = {}\r\n# for i in t:\r\n#     # need[i] += 1\r\n#     need[i] = need.get(i,0) + 1\r\n# print(need)\r\n\r\n\r\n# a = 3\r\n# temp = \"\"\r\n# temp += str(a) + \" \"\r\n# temp += \"b\"\r\n# print(temp)\r\n\r\n\r\n\r\n#法二：理论都是一样的，但是Python 不需要输入那么多的参数\r\n# n,td,tc = map(int,input().split())\r\n# damage = list(map(int,input().split()))\r\n# coin = list(map(int,input().split()))\r\n# pathDamage,listDamage,listCoin,pathCoin = [],[],[],[]\r\n# def fightMonster(td,tc):\r\n#     if sum(damage) <= td:\r\n#         return 0 \r\n#     def dfs(pathDamage,pathCoin,begin,td,tc):\r\n#         if tc <=0:\r\n#             return \r\n#         if  td < 0:\r\n#             listCoin.append(sum(pathCoin))\r\n#             listDamage.append(pathDamage)\r\n#             if begin < len(damage):\r\n#                 dfs(pathDamage+[damage[begin]],pathCoin+ [coin[begin]],begin,td-damage[begin],tc-coin[begin])\r\n#             return \r\n#         for index in range(begin,n):\r\n#             dfs(pathDamage+[damage[index]],pathCoin+ [coin[index]],index+1,td-damage[index],tc-coin[index])\r\n\r\n#     dfs(pathDamage,pathCoin,0,td,tc)\r\n# fightMonster(td,tc)\r\n# print(pathDamage,listDamage,listCoin,pathCoin,len(listDamage),len(listCoin))\r\n\r\n\r\n\r\n##网易打怪兽\r\n\r\n# n,td,tc = map(int,input().split())\r\n# damage = list(map(int,input().split()))\r\n# coin = list(map(int,input().split()))\r\n# pathDamage,listDamage = [],[]\r\n# def fightMonster(td,tc):\r\n#     if sum(damage) <= td:\r\n#         return 0 \r\n#     def dfs(pathDamage,begin,td,tc):\r\n#         if tc <=0:\r\n#             return \r\n#         if  td < 0:\r\n#             listDamage.append(pathDamage)\r\n#             if begin < len(damage):\r\n#                 dfs(pathDamage+[damage[begin]],begin,td-damage[begin],tc-coin[begin])\r\n#             return \r\n#         for index in range(begin,n):\r\n#             dfs(pathDamage+[damage[index]],index+1,td-damage[index],tc-coin[index])\r\n\r\n#     dfs(pathDamage,0,td,tc)\r\n# fightMonster(td,tc)\r\n# print(pathDamage,listDamage,len(listDamage))\r\n\r\n\r\n\r\n## noAc\r\n# str1 = input()\r\n# def number(str1):\r\n#     i = res = 0\r\n#     while \"ab\" in str1:\r\n#         if str1[i:i+2] ==\"ab\":\r\n#             str1 = str1[:i] + \"bba\" + str1[i+2:]\r\n#             res += 1\r\n#             res %=1000000007\r\n#             #这里必须加这个因为aaab第一次编程aabba了\r\n#             i -= 1\r\n#         else:\r\n#             i += 1\r\n#     return res\r\n# out = number(str1)               \r\n# print(out)\r\n\r\n\r\n\r\n\r\na = \"Epoch: [0][0/915]\t lr:0.01000 Time 14.648 (14.648)\tLoss 8.4618 (8.4618)\tPrec@1 0.000 (0.000)\"\r\nb = a.split()\r\nprint(b)\r\nprint(b[-5])\r\nprint(b[-1].strip(\"()\"))\r\nprint(100)\r\n\r\n# c = \"(0.000)\"\r\n# print(c.strip(\"()\"))"
        }
    ]
}